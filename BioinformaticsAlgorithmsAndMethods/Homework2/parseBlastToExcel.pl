#!/usr/bin/perl
##############################################################
# Script that generates an annotated k means algorithm       #
# results file.  Usage follows:                              #
# annotateKMeansResults <algorithmResultsFile>  <goFile>     #
##############################################################

$algorithmResultsFile = $ARGV[0];
chomp $algorithmResultsFile;
$goFile = $ARGV[1];
chomp $goFile;

# check to see if the specified BLAST file exists
# if so then continue processing otherwise display
# the appropriate error message
if ( -f $blastFile )  {
            
    # generate the alignment details output filename
    $outputFilename = "alignmentDetails-" . $blastFile;
    
    # if the output file already exists, rename the
    # original appending ".old".  this is done to
    # prevent the user from accidently deleting an
    # output file generated from a previous run
    if ( -f $outputFilename ) {
        print "Output file already exists, appending existing file with '.old' before processing new request!\n";
        rename $outputFilename, $outputFilename . ".old";
    }
    
    # open up the output file.  note that the
    # contents of the file will be overwritten 
    # (e.g. using '>' when opening the file)
    open(OUTPUTFILE, ">$outputFilename");
    
    # write the output file header
    &writeOutputFileHeader;
    
    # open the BLAST results file
    open(BLASTFILE, $blastFile);
    
    # extract the contents of the file into a single variable
    $blastData = join('', <BLASTFILE>);
    
    # close the BLAST results file
    close(BLASTFILE);
    
    # extract the different sections from the BLAST results
    ($beginningAnnotation, $blastAlignments, $endingAnnotation) = 
        ($blastData =~/(.*^ALIGNMENTS\n)(.*)(^  Database:.*)/ms);
    
    # parse the alignments section
    parseBlastAlignments( $blastAlignments );
    
    # close the output file
    close(OUTPUTFILE);
    
} else {
        
    # specified BLAST results file not found, display error message
    print "Specified BLAST results file does not exist, please try again.\n";        

}


############## subroutine writeOutputFileHeader ###############
# writes the output file header to the alignment details      #
# output file                                                 #
###############################################################
sub writeOutputFileHeader {
   print OUTPUTFILE "GI Header\t";
   print OUTPUTFILE "Length\t";
   print OUTPUTFILE "Score\t";
   print OUTPUTFILE "Expected Value\t";
   print OUTPUTFILE "Identity Percentage\t";
   print OUTPUTFILE "Positives Percentage\t";
   print OUTPUTFILE "Gaps Percentage\n";
}


############## subroutine parseBlastAlignments ################
# subroutine that parses BLAST alignments into an tab         #
# seperated list file.  the items included follow:            #
#                                                             #
#    - alignment FASTA header                                 #
#    - alignment length                                       #
#    - score (bits)                                           #
#    - expected value                                         #
#    - identity percentage                                    #
#    - postives percentage                                    #
#    - gaps percentage                                        #
#                                                             #
# the file generated by this subroutine adheres to the        #
# following naming scheme: alignments<DateTime>.txt.          #
###############################################################
sub parseBlastAlignments {
    
    my ($alignments) = @_;
    my (%alignmentDetailsHash) = ();
    
    # iterate over each alignment and extract
    # the desired alignment details into a hash
    # for each alignment, append a new line item 
    # in the tab delimited file
    while( $alignments =~ /^>.*\n(^(?!>).*\n)+/gm) {
        
        # grab the single alignment data
        my ($alignment) = $&;
        
        ## parse the header
        $alignment =~ /^>([^\n]*)/;
        my ($header ) = $1;
        $alignmentDetailsHash{"header"} = $header;
        
        # parse the alignment length
        $alignment =~ /.*Length = ([0-9]*)/s;
        my ($length ) = $1;
        $alignmentDetailsHash{"length"} = $length;
        
        # parse the score
        $alignment =~ /.*Score =  ([0-9]*)/s;
        my ($score ) = $1;
        $alignmentDetailsHash{"score"} = $score;
        
        # parse the e-value
        $alignment =~ /.*Expect = ([0-9]*\.?e?-?[0-9]*)/s;
        my ($eValue ) = $1;
        $alignmentDetailsHash{"eValue"} = $eValue;
        
        # parse the identity
        $alignment =~ /.*Identities = [0-9]*\/[0-9]* \(([0-9]*)/s;
        my ($identity ) = $1;
        $alignmentDetailsHash{"identity"} = $identity;
        
        # parse the positives
        $alignment =~ /.*Positives = [0-9]*\/[0-9]* \(([0-9]*)/s;
        my ($positives ) = $1;
        $alignmentDetailsHash{"positives"} = $positives;
        
        # parse the gaps
        $alignment =~ /.*Gaps = [0-9]*\/[0-9]* \(([0-9]*)/s;
        my ($gaps ) = $1;
        $alignmentDetailsHash{"gaps"} = $gaps;
     
        # write the contents of the alignment hash to file
        writeAlignmentEntry( %alignmentDetailsHash );
        
    } # END alignment while
        
}


############## subroutine writeAlignmentEntry #################
# creates the output file header                              #
###############################################################
sub writeAlignmentEntry {
   my (%alginmentEntry) = @_;
   print OUTPUTFILE $alginmentEntry{"header"} . "\t";
   print OUTPUTFILE $alginmentEntry{"length"} . "\t";
   print OUTPUTFILE $alginmentEntry{"score"} . "\t";
   print OUTPUTFILE $alginmentEntry{"eValue"} . "\t";
   print OUTPUTFILE $alginmentEntry{"identity"} . "\t";
   print OUTPUTFILE $alginmentEntry{"positives"} . "\t";
   print OUTPUTFILE $alginmentEntry{"gaps"} . "\n";
}